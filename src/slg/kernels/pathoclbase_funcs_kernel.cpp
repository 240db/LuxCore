#include <string>
namespace slg { namespace ocl {
std::string KernelSource_pathoclbase_funcs = 
"#line 2 \"pathoclbase_funcs.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2018 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxCoreRender.                                   *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"// List of symbols defined at compile time:\n"
"//  PARAM_RAY_EPSILON_MIN\n"
"//  PARAM_RAY_EPSILON_MAX\n"
"//  PARAM_HAS_IMAGEMAPS\n"
"//  PARAM_HAS_PASSTHROUGH\n"
"//  PARAM_USE_PIXEL_ATOMICS\n"
"//  PARAM_HAS_BUMPMAPS\n"
"//  PARAM_ACCEL_BVH or PARAM_ACCEL_MBVH or PARAM_ACCEL_QBVH or PARAM_ACCEL_MQBVH\n"
"//  PARAM_LIGHT_WORLD_RADIUS_SCALE\n"
"//  PARAM_TRIANGLE_LIGHT_HAS_VERTEX_COLOR\n"
"//  PARAM_HAS_VOLUMEs (and SCENE_DEFAULT_VOLUME_INDEX)\n"
"\n"
"// To enable single material support\n"
"//  PARAM_ENABLE_MAT_MATTE\n"
"//  PARAM_ENABLE_MAT_MIRROR\n"
"//  PARAM_ENABLE_MAT_GLASS\n"
"//  PARAM_ENABLE_MAT_ARCHGLASS\n"
"//  PARAM_ENABLE_MAT_MIX\n"
"//  PARAM_ENABLE_MAT_NULL\n"
"//  PARAM_ENABLE_MAT_MATTETRANSLUCENT\n"
"//  PARAM_ENABLE_MAT_ROUGHMATTETRANSLUCENT\n"
"//  PARAM_ENABLE_MAT_GLOSSY2\n"
"//  PARAM_ENABLE_MAT_METAL2\n"
"//  PARAM_ENABLE_MAT_ROUGHGLASS\n"
"//  PARAM_ENABLE_MAT_CLOTH\n"
"//  PARAM_ENABLE_MAT_CARPAINT\n"
"//  PARAM_ENABLE_MAT_GLOSSYTRANSLUCENT\n"
"//  PARAM_ENABLE_MAT_GLOSSYCOATING\n"
"//  PARAM_ENABLE_MAT_CLEAR_VOL\n"
"/// etc.\n"
"\n"
"// To enable single texture support\n"
"//  PARAM_ENABLE_TEX_CONST_FLOAT\n"
"//  PARAM_ENABLE_TEX_CONST_FLOAT3\n"
"//  PARAM_ENABLE_TEX_CONST_FLOAT4\n"
"//  PARAM_ENABLE_TEX_IMAGEMAP\n"
"//  PARAM_ENABLE_TEX_SCALE\n"
"//  etc.\n"
"\n"
"// Film related parameters:\n"
"//  PARAM_FILM_RADIANCE_GROUP_COUNT\n"
"//  PARAM_FILM_CHANNELS_HAS_ALPHA\n"
"//  PARAM_FILM_CHANNELS_HAS_DEPTH\n"
"//  PARAM_FILM_CHANNELS_HAS_POSITION\n"
"//  PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL\n"
"//  PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL\n"
"//  PARAM_FILM_CHANNELS_HAS_MATERIAL_ID\n"
"//  PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE\n"
"//  PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY\n"
"//  PARAM_FILM_CHANNELS_HAS_EMISSION\n"
"//  PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE\n"
"//  PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY\n"
"//  PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR\n"
"//  PARAM_FILM_CHANNELS_HAS_MATERIAL_ID_MASK (and PARAM_FILM_MASK_MATERIAL_ID)\n"
"//  PARAM_FILM_CHANNELS_HAS_BY_MATERIAL_ID (and PARAM_FILM_BY_MATERIAL_ID)\n"
"//  PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK\n"
"//  PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK\n"
"//  PARAM_FILM_CHANNELS_HAS_UV\n"
"//  PARAM_FILM_CHANNELS_HAS_RAYCOUNT\n"
"//  PARAM_FILM_CHANNELS_HAS_BY_MATERIAL_ID (and PARAM_FILM_BY_MATERIAL_ID)\n"
"//  PARAM_FILM_CHANNELS_HAS_IRRADIANCE\n"
"//  PARAM_FILM_CHANNELS_HAS_OBJECT_ID\n"
"//  PARAM_FILM_CHANNELS_HAS_OBJECT_ID_MASK (and PARAM_FILM_MASK_OBJECT_ID)\n"
"//  PARAM_FILM_CHANNELS_HAS_BY_OBJECT_ID (and PARAM_FILM_BY_OBJECT_ID)\n"
"//  PARAM_FILM_CHANNELS_HAS_SAMPLECOUNT\n"
"//  PARAM_FILM_CHANNELS_HAS_CONVERGENCE\n"
"\n"
"// (optional)\n"
"//  PARAM_HAS_INFINITELIGHT\n"
"//  PARAM_HAS_SUNLIGHT\n"
"//  PARAM_HAS_SKYLIGHT2\n"
"//  PARAM_HAS_POINTLIGHT\n"
"//  PARAM_HAS_MAPPOINTLIGHT\n"
"//  PARAM_HAS_SPOTLIGHT\n"
"//  PARAM_HAS_PROJECTIONLIGHT\n"
"//  PARAM_HAS_CONSTANTINFINITELIGHT\n"
"//  PARAM_HAS_SHARPDISTANTLIGHT\n"
"//  PARAM_HAS_DISTANTLIGHT\n"
"//  PARAM_HAS_LASERLIGHT\n"
"//  PARAM_HAS_TRIANGLELIGHT\n"
"//  PARAM_HAS_ENVLIGHTS (if it has any env. light)\n"
"\n"
"// List of symbols defined at compile time:\n"
"//  PARAM_MAX_PATH_DEPTH\n"
"//  PARAM_MAX_PATH_DEPTH_DIFFUSE\n"
"//  PARAM_MAX_PATH_DEPTH_GLOSSY\n"
"//  PARAM_MAX_PATH_DEPTH_SPECULAR\n"
"//  PARAM_RR_DEPTH\n"
"//  PARAM_RR_CAP\n"
"\n"
"// (optional)\n"
"//  PARAM_CAMERA_TYPE (0 = Perspective, 1 = Orthographic, 2 = Stereo)\n"
"//  PARAM_CAMERA_ENABLE_CLIPPING_PLANE\n"
"//  PARAM_CAMERA_ENABLE_OCULUSRIFT_BARREL\n"
"\n"
"// (optional)\n"
"//  PARAM_IMAGE_FILTER_TYPE (0 = No filter, 1 = Box, 2 = Gaussian, 3 = Mitchell, 4 = Blackman-Harris)\n"
"//  PARAM_IMAGE_FILTER_WIDTH_X\n"
"//  PARAM_IMAGE_FILTER_WIDTH_Y\n"
"//  PARAM_IMAGE_FILTER_PIXEL_WIDTH_X\n"
"//  PARAM_IMAGE_FILTER_PIXEL_WIDTH_Y\n"
"// (Box filter)\n"
"// (Gaussian filter)\n"
"//  PARAM_IMAGE_FILTER_GAUSSIAN_ALPHA\n"
"// (Mitchell filter)\n"
"//  PARAM_IMAGE_FILTER_MITCHELL_B\n"
"//  PARAM_IMAGE_FILTER_MITCHELL_C\n"
"// (MitchellSS filter)\n"
"//  PARAM_IMAGE_FILTER_MITCHELL_B\n"
"//  PARAM_IMAGE_FILTER_MITCHELL_C\n"
"//  PARAM_IMAGE_FILTER_MITCHELL_A0\n"
"//  PARAM_IMAGE_FILTER_MITCHELL_A1\n"
"\n"
"// (optional)\n"
"//  PARAM_SAMPLER_TYPE (0 = Inlined Random, 1 = Metropolis, 2 = Sobol, 3 = TilePathSampler)\n"
"// (Metropolis)\n"
"//  PARAM_SAMPLER_METROPOLIS_LARGE_STEP_RATE\n"
"//  PARAM_SAMPLER_METROPOLIS_MAX_CONSECUTIVE_REJECT\n"
"//  PARAM_SAMPLER_METROPOLIS_IMAGE_MUTATION_RANGE\n"
"// (Sobol)\n"
"//  PARAM_SAMPLER_SOBOL_STARTOFFSET\n"
"\n"
"/*void MangleMemory(__global unsigned char *ptr, const size_t size) {\n"
"	Seed seed;\n"
"	Rnd_Init(7 + get_global_id(0), &seed);\n"
"\n"
"	for (uint i = 0; i < size; ++i)\n"
"		*ptr++ = (unsigned char)(Rnd_UintValue(&seed) & 0xff);\n"
"}*/\n"
"\n"
"bool Scene_Intersect(\n"
"		const bool cameraRay,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfo,\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float passThrough,\n"
"#endif\n"
"		__global Ray *ray,\n"
"		__global RayHit *rayHit,\n"
"		__global BSDF *bsdf,\n"
"		float3 *connectionThroughput,  const float3 pathThroughput,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const SceneObject* restrict sceneObjs,\n"
"		__global const uint *meshTriLightDefsOffset,\n"
"		__global const Point* restrict vertices,\n"
"		__global const Vector* restrict vertNormals,\n"
"		__global const UV* restrict vertUVs,\n"
"		__global const Spectrum* restrict vertCols,\n"
"		__global const float* restrict vertAlphas,\n"
"		__global const Triangle* restrict triangles\n"
"		MATERIALS_PARAM_DECL\n"
"		) {\n"
"	*connectionThroughput = WHITE;\n"
"	const bool hit = (rayHit->meshIndex != NULL_INDEX);\n"
"\n"
"	const uint sceneObjectIndex = rayHit->meshIndex;\n"
"	if (cameraRay && hit && sceneObjs[rayHit->meshIndex].cameraInvisible) {\n"
"		ray->mint = rayHit->t + MachineEpsilon_E(rayHit->t);\n"
"\n"
"		// A safety check\n"
"		if (ray->mint >= ray->maxt)\n"
"			return false;\n"
"		else\n"
"			return true;\n"
"	}\n"
"\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"	uint rayVolumeIndex = volInfo->currentVolumeIndex;\n"
"#endif\n"
"	if (hit) {\n"
"		// Initialize the BSDF of the hit point\n"
"		BSDF_Init(bsdf,\n"
"				meshDescs,\n"
"				sceneObjs,\n"
"				meshTriLightDefsOffset,\n"
"				vertices,\n"
"				vertNormals,\n"
"				vertUVs,\n"
"				vertCols,\n"
"				vertAlphas,\n"
"				triangles, ray, rayHit\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"				, passThrough\n"
"#endif\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"				, volInfo\n"
"#endif\n"
"				MATERIALS_PARAM\n"
"				);\n"
"\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		rayVolumeIndex = bsdf->hitPoint.intoObject ? bsdf->hitPoint.exteriorVolumeIndex : bsdf->hitPoint.interiorVolumeIndex;\n"
"#endif\n"
"	}\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"	else if (rayVolumeIndex == NULL_INDEX) {\n"
"		// No volume information, I use the default volume\n"
"		rayVolumeIndex = SCENE_DEFAULT_VOLUME_INDEX;\n"
"	}\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"	// Check if there is volume scatter event\n"
"	if (rayVolumeIndex != NULL_INDEX) {\n"
"		// This applies volume transmittance too\n"
"		// Note: by using passThrough here, I introduce subtle correlation\n"
"		// between scattering events and pass-through events\n"
"		float3 connectionEmission = BLACK;\n"
"\n"
"		const float t = Volume_Scatter(&mats[rayVolumeIndex], ray,\n"
"				hit ? rayHit->t : ray->maxt,\n"
"				passThrough, volInfo->scatteredStart,\n"
"				connectionThroughput, &connectionEmission,\n"
"				tmpHitPoint\n"
"				TEXTURES_PARAM);\n"
"\n"
"		// Add the volume emitted light to the appropriate light group\n"
"		if (!Spectrum_IsBlack(connectionEmission) && sampleResult)\n"
"			SampleResult_AddEmission(sampleResult, BSDF_GetLightID(bsdf\n"
"				MATERIALS_PARAM),\n"
"					pathThroughput, connectionEmission);\n"
"\n"
"		if (t > 0.f) {\n"
"			// There was a volume scatter event\n"
"\n"
"			// I have to set RayHit fields even if there wasn't a real\n"
"			// ray hit\n"
"			rayHit->t = t;\n"
"			// This is a trick in order to have RayHit::Miss() return\n"
"			// false. I assume 0xfffffffeu will trigger a memory fault if\n"
"			// used (and the bug will be noticed)\n"
"			rayHit->meshIndex = 0xfffffffeu;\n"
"\n"
"			BSDF_InitVolume(bsdf, mats, ray, rayVolumeIndex, t, passThrough);\n"
"			volInfo->scatteredStart = true;\n"
"\n"
"			return false;\n"
"		}\n"
"	}\n"
"#endif\n"
"\n"
"	if (hit) {\n"
"		// Check if the volume priority system tells me to continue to trace the ray\n"
"		bool continueToTrace =\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			PathVolumeInfo_ContinueToTrace(volInfo, bsdf\n"
"				MATERIALS_PARAM);\n"
"#else\n"
"		false;\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		// Check if it is a pass through point\n"
"		if (!continueToTrace) {\n"
"			const float3 passThroughTrans = BSDF_GetPassThroughTransparency(bsdf\n"
"				MATERIALS_PARAM);\n"
"			if (!Spectrum_IsBlack(passThroughTrans)) {\n"
"				*connectionThroughput *= passThroughTrans;\n"
"\n"
"				// It is a pass through point, continue to trace the ray\n"
"				continueToTrace = true;\n"
"			}\n"
"		}\n"
"#endif\n"
"\n"
"		if (continueToTrace) {\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			// Update volume information\n"
"			const BSDFEvent eventTypes = BSDF_GetEventTypes(bsdf\n"
"						MATERIALS_PARAM);\n"
"			PathVolumeInfo_Update(volInfo, eventTypes, bsdf\n"
"					MATERIALS_PARAM);\n"
"#endif\n"
"\n"
"			// It is a transparent material, continue to trace the ray\n"
"			ray->mint = rayHit->t + MachineEpsilon_E(rayHit->t);\n"
"\n"
"			// A safety check\n"
"			if (ray->mint >= ray->maxt)\n"
"				return false;\n"
"			else\n"
"				return true;\n"
"		} else\n"
"			return false;\n"
"	} else {\n"
"		// Nothing was hit, stop tracing the ray\n"
"		return false;\n"
"	}\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// PathDepthInfo\n"
"//------------------------------------------------------------------------------\n"
"\n"
"void PathDepthInfo_Init(__global PathDepthInfo *depthInfo) {\n"
"	depthInfo->depth = 0;\n"
"	depthInfo->diffuseDepth = 0;\n"
"	depthInfo->glossyDepth = 0;\n"
"	depthInfo->specularDepth = 0;\n"
"}\n"
"\n"
"void PathDepthInfo_IncDepths(__global PathDepthInfo *depthInfo, const BSDFEvent event) {\n"
"	++(depthInfo->depth);\n"
"	if (event & DIFFUSE)\n"
"		++(depthInfo->diffuseDepth);\n"
"	if (event & GLOSSY)\n"
"		++(depthInfo->glossyDepth);\n"
"	if (event & SPECULAR)\n"
"		++(depthInfo->specularDepth);\n"
"}\n"
"\n"
"bool PathDepthInfo_IsLastPathVertex(__global PathDepthInfo *depthInfo, const BSDFEvent event) {\n"
"	return (depthInfo->depth + 1 >= PARAM_MAX_PATH_DEPTH) ||\n"
"			((event & DIFFUSE) && (depthInfo->diffuseDepth + 1 >= PARAM_MAX_PATH_DEPTH_DIFFUSE)) ||\n"
"			((event & GLOSSY) && (depthInfo->glossyDepth + 1 >= PARAM_MAX_PATH_DEPTH_GLOSSY)) ||\n"
"			((event & SPECULAR) && (depthInfo->specularDepth + 1 >= PARAM_MAX_PATH_DEPTH_SPECULAR));\n"
"}\n"
"\n"
"bool PathDepthInfo_CheckComponentDepths(const BSDFEvent component) {\n"
"	return ((PARAM_MAX_PATH_DEPTH_DIFFUSE > 0) && (component & DIFFUSE)) ||\n"
"			((PARAM_MAX_PATH_DEPTH_GLOSSY > 0) && (component & GLOSSY)) ||\n"
"			((PARAM_MAX_PATH_DEPTH_SPECULAR > 0) && (component & SPECULAR));\n"
"}\n"
"\n"
"uint PathDepthInfo_GetRRDepth(__global PathDepthInfo *depthInfo) {\n"
"	return depthInfo->diffuseDepth + depthInfo->glossyDepth;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Init functions\n"
"//------------------------------------------------------------------------------\n"
"\n"
"void InitSampleResult(\n"
"		__global Sample *sample,\n"
"		__global float *sampleDataPathBase,\n"
"		const uint filmWidth, const uint filmHeight,\n"
"		const uint filmSubRegion0, const uint filmSubRegion1,\n"
"		const uint filmSubRegion2, const uint filmSubRegion3,\n"
"		__global float *pixelFilterDistribution,\n"
"		Seed *seed) {\n"
"	SampleResult_Init(&sample->result);\n"
"\n"
"	float filmX = Sampler_GetSamplePath(seed, sample, sampleDataPathBase, IDX_SCREEN_X);\n"
"	float filmY = Sampler_GetSamplePath(seed, sample, sampleDataPathBase, IDX_SCREEN_Y);\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 1)\n"
"	// Metropolis return IDX_SCREEN_X and IDX_SCREEN_Y between [0.0, 1.0] instead\n"
"	// that in film pixels like RANDOM and SOBOL samplers\n"
"	filmX = filmSubRegion0 + filmX * (filmSubRegion1 - filmSubRegion0 + 1);\n"
"	filmY = filmSubRegion2 + filmY * (filmSubRegion3 - filmSubRegion2 + 1);\n"
"#endif\n"
"\n"
"	const uint pixelX = min(Floor2UInt(filmX), filmSubRegion1);\n"
"	const uint pixelY = min(Floor2UInt(filmY), filmSubRegion3);\n"
"	const float uSubPixelX = filmX - pixelX;\n"
"	const float uSubPixelY = filmY - pixelY;\n"
"\n"
"	sample->result.pixelX = pixelX;\n"
"	sample->result.pixelY = pixelY;\n"
"\n"
"	// Sample according the pixel filter distribution\n"
"	float distX, distY;\n"
"	FilterDistribution_SampleContinuous(pixelFilterDistribution, uSubPixelX, uSubPixelY, &distX, &distY);\n"
"\n"
"	sample->result.filmX = pixelX + .5f + distX;\n"
"	sample->result.filmY = pixelY + .5f + distY;\n"
"}\n"
"\n"
"void GenerateEyePath(\n"
"		__global GPUTaskDirectLight *taskDirectLight,\n"
"		__global GPUTaskState *taskState,\n"
"		__global Sample *sample,\n"
"		__global float *sampleDataPathBase,\n"
"		__global const Camera* restrict camera,\n"
"		const uint filmWidth, const uint filmHeight,\n"
"		const uint filmSubRegion0, const uint filmSubRegion1,\n"
"		const uint filmSubRegion2, const uint filmSubRegion3,\n"
"		__global float *pixelFilterDistribution,\n"
"		__global Ray *ray,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfo,\n"
"#endif\n"
"		Seed *seed\n"
"#if defined(RENDER_ENGINE_TILEPATHOCL) || defined(RENDER_ENGINE_RTPATHOCL)\n"
"		// cameraFilmWidth/cameraFilmHeight and filmWidth/filmHeight are usually\n"
"		// the same. They are different when doing tile rendering\n"
"		, const uint cameraFilmWidth, const uint cameraFilmHeight,\n"
"		const uint tileStartX, const uint tileStartY\n"
"#endif\n"
"		) {\n"
"	InitSampleResult(sample, sampleDataPathBase,\n"
"			filmWidth, filmHeight,\n"
"			filmSubRegion0, filmSubRegion1,\n"
"			filmSubRegion2, filmSubRegion3,\n"
"			pixelFilterDistribution, seed);\n"
"\n"
"	// Generate the came ray\n"
"	const float time = Sampler_GetSamplePath(seed, sample, sampleDataPathBase, IDX_EYE_TIME);\n"
"\n"
"	const float dofSampleX = Sampler_GetSamplePath(seed, sample, sampleDataPathBase, IDX_DOF_X);\n"
"	const float dofSampleY = Sampler_GetSamplePath(seed, sample, sampleDataPathBase, IDX_DOF_Y);\n"
"\n"
"#if defined(RENDER_ENGINE_TILEPATHOCL) || defined(RENDER_ENGINE_RTPATHOCL)\n"
"	Camera_GenerateRay(camera, cameraFilmWidth, cameraFilmHeight,\n"
"			ray,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			volInfo,\n"
"#endif\n"
"			sample->result.filmX + tileStartX, sample->result.filmY + tileStartY,\n"
"			time,\n"
"			dofSampleX, dofSampleY);\n"
"#else\n"
"	Camera_GenerateRay(camera, filmWidth, filmHeight,\n"
"			ray,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			volInfo,\n"
"#endif\n"
"			sample->result.filmX, sample->result.filmY,\n"
"			time,\n"
"			dofSampleX, dofSampleY);\n"
"#endif\n"
"\n"
"	// Initialize the path state\n"
"	taskState->state = MK_RT_NEXT_VERTEX;\n"
"	PathDepthInfo_Init(&taskState->depthInfo);\n"
"	VSTORE3F(WHITE, taskState->throughput.c);\n"
"	taskDirectLight->lastBSDFEvent = SPECULAR; // SPECULAR is required to avoid MIS\n"
"	taskDirectLight->lastPdfW = 1.f;\n"
"\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"	// This is a bit tricky. I store the passThroughEvent in the BSDF\n"
"	// before of the initialization because it can be used during the\n"
"	// tracing of next path vertex ray.\n"
"\n"
"	taskState->bsdf.hitPoint.passThroughEvent = Sampler_GetSamplePath(seed, sample, sampleDataPathBase, IDX_EYE_PASSTHROUGH);\n"
"#endif\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"	sample->result.directShadowMask = 1.f;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	sample->result.indirectShadowMask = 1.f;\n"
"#endif\n"
"\n"
"	sample->result.lastPathVertex = (PARAM_MAX_PATH_DEPTH == 1);\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Utility functions\n"
"//------------------------------------------------------------------------------\n"
"\n"
"bool CheckDirectHitVisibilityFlags(__global const LightSource* restrict lightSource,\n"
"		__global PathDepthInfo *depthInfo,\n"
"		const BSDFEvent lastBSDFEvent) {\n"
"	if (depthInfo->depth == 0)\n"
"		return true;\n"
"\n"
"	if ((lastBSDFEvent & DIFFUSE) && (lightSource->visibility & DIFFUSE))\n"
"		return true;\n"
"	if ((lastBSDFEvent & GLOSSY) && (lightSource->visibility & GLOSSY))\n"
"		return true;\n"
"	if ((lastBSDFEvent & SPECULAR) && (lightSource->visibility & SPECULAR))\n"
"		return true;\n"
"\n"
"	return false;\n"
"}\n"
"\n"
"#if defined(PARAM_HAS_ENVLIGHTS)\n"
"void DirectHitInfiniteLight(\n"
"		__global PathDepthInfo *depthInfo,\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		__global const Spectrum* restrict pathThroughput,\n"
"		const float3 eyeDir, const float lastPdfW,\n"
"		__global SampleResult *sampleResult\n"
"		LIGHTS_PARAM_DECL) {\n"
"	const float3 throughput = VLOAD3F(pathThroughput->c);\n"
"\n"
"	for (uint i = 0; i < envLightCount; ++i) {\n"
"		__global const LightSource* restrict light = &lights[envLightIndices[i]];\n"
"\n"
"		// Check if the light source is visible according the settings\n"
"		if (!CheckDirectHitVisibilityFlags(light, depthInfo, lastBSDFEvent))\n"
"			continue;\n"
"\n"
"		float directPdfW;\n"
"		const float3 lightRadiance = EnvLight_GetRadiance(light, -eyeDir, &directPdfW\n"
"				LIGHTS_PARAM);\n"
"\n"
"		if (!Spectrum_IsBlack(lightRadiance)) {\n"
"			// MIS between BSDF sampling and direct light sampling\n"
"			const float weight = ((lastBSDFEvent & SPECULAR) ? 1.f : PowerHeuristic(lastPdfW, directPdfW));\n"
"\n"
"			SampleResult_AddEmission(sampleResult, light->lightID, throughput, weight * lightRadiance);\n"
"		}\n"
"	}\n"
"}\n"
"#endif\n"
"\n"
"void DirectHitFiniteLight(\n"
"		__global PathDepthInfo *depthInfo,\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		__global const Spectrum* restrict pathThroughput, const float distance, __global BSDF *bsdf,\n"
"		const float lastPdfW, __global SampleResult *sampleResult\n"
"		LIGHTS_PARAM_DECL) {\n"
"	__global const LightSource* restrict light = &lights[bsdf->triangleLightSourceIndex];\n"
"\n"
"	// Check if the light source is visible according the settings\n"
"	if (!CheckDirectHitVisibilityFlags(light, depthInfo, lastBSDFEvent))\n"
"		return;\n"
"	\n"
"	float directPdfA;\n"
"	const float3 emittedRadiance = BSDF_GetEmittedRadiance(bsdf, &directPdfA\n"
"			LIGHTS_PARAM);\n"
"\n"
"	if (!Spectrum_IsBlack(emittedRadiance)) {\n"
"		// Add emitted radiance\n"
"		float weight = 1.f;\n"
"		if (!(lastBSDFEvent & SPECULAR)) {\n"
"			const float lightPickProb = Scene_SampleLightPdf(lightsDistribution,\n"
"					light->lightSceneIndex);\n"
"			const float directPdfW = PdfAtoW(directPdfA, distance,\n"
"					fabs(dot(VLOAD3F(&bsdf->hitPoint.fixedDir.x), VLOAD3F(&bsdf->hitPoint.shadeN.x))));\n"
"\n"
"			// MIS between BSDF sampling and direct light sampling\n"
"			weight = PowerHeuristic(lastPdfW, directPdfW * lightPickProb);\n"
"		}\n"
"\n"
"		SampleResult_AddEmission(sampleResult, BSDF_GetLightID(bsdf\n"
"				MATERIALS_PARAM), VLOAD3F(pathThroughput->c), weight * emittedRadiance);\n"
"	}\n"
"}\n"
"\n"
"float RussianRouletteProb(const float3 color) {\n"
"	return clamp(Spectrum_Filter(color), PARAM_RR_CAP, 1.f);\n"
"}\n"
"\n"
"bool DirectLight_Illuminate(\n"
"		__global BSDF *bsdf,\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"		__global HitPoint *tmpHitPoint,\n"
"		const float u0, const float u1, const float u2,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float lightPassThroughEvent,\n"
"#endif\n"
"		const float3 point,\n"
"		__global DirectLightIlluminateInfo *info\n"
"		LIGHTS_PARAM_DECL) {\n"
"	// Select the light strategy to use\n"
"	__global const float* restrict lightDist = BSDF_IsShadowCatcherOnlyInfiniteLights(bsdf MATERIALS_PARAM) ?\n"
"		infiniteLightSourcesDistribution : lightsDistribution;\n"
"\n"
"	// Pick a light source to sample\n"
"	float lightPickPdf;\n"
"	const uint lightIndex = Scene_SampleLights(lightDist, u0, &lightPickPdf);\n"
"	if (lightPickPdf <= 0.f)\n"
"		return false;\n"
"\n"
"	__global const LightSource* restrict light = &lights[lightIndex];\n"
"\n"
"	info->lightIndex = lightIndex;\n"
"	info->lightID = light->lightID;\n"
"	info->pickPdf = lightPickPdf;\n"
"\n"
"	// Illuminate the point\n"
"	float3 lightRayDir;\n"
"	float distance, directPdfW;\n"
"	const float3 lightRadiance = Light_Illuminate(\n"
"			&lights[lightIndex],\n"
"			point,\n"
"			u1, u2,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			lightPassThroughEvent,\n"
"#endif\n"
"			worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"			tmpHitPoint,		\n"
"			&lightRayDir, &distance, &directPdfW\n"
"			LIGHTS_PARAM);\n"
"	\n"
"	if (Spectrum_IsBlack(lightRadiance))\n"
"		return false;\n"
"	else {\n"
"		VSTORE3F(lightRayDir, &info->dir.x);\n"
"		info->distance = distance;\n"
"		info->directPdfW = directPdfW;\n"
"		VSTORE3F(lightRadiance, info->lightRadiance.c);\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"		VSTORE3F(lightRadiance, info->lightIrradiance.c);\n"
"#endif\n"
"		return true;\n"
"	}\n"
"}\n"
"\n"
"bool DirectLight_BSDFSampling(\n"
"		__global DirectLightIlluminateInfo *info,\n"
"		const float time,\n"
"		const bool lastPathVertex,\n"
"		__global PathDepthInfo *depthInfo,\n"
"		__global BSDF *bsdf,\n"
"		__global Ray *shadowRay\n"
"		LIGHTS_PARAM_DECL) {\n"
"	const float3 lightRayDir = VLOAD3F(&info->dir.x);\n"
"	\n"
"	// Sample the BSDF\n"
"	BSDFEvent event;\n"
"	float bsdfPdfW;\n"
"	const float3 bsdfEval = BSDF_Evaluate(bsdf,\n"
"			lightRayDir, &event, &bsdfPdfW\n"
"			MATERIALS_PARAM);\n"
"\n"
"	if (Spectrum_IsBlack(bsdfEval))\n"
"		return false;\n"
"	\n"
"	// Create a copy of depthInfo for later restore\n"
"	PathDepthInfo depthInfoCopy = *depthInfo;\n"
"\n"
"	// Create a new DepthInfo for the path to the light source\n"
"	PathDepthInfo_IncDepths(depthInfo, event);\n"
"\n"
"	const float cosThetaToLight = fabs(dot(lightRayDir, VLOAD3F(&bsdf->hitPoint.shadeN.x)));\n"
"	const float directLightSamplingPdfW = info->directPdfW * info->pickPdf;\n"
"	const float factor = 1.f / directLightSamplingPdfW;\n"
"\n"
"	// Russian Roulette\n"
"	bsdfPdfW *= (PathDepthInfo_GetRRDepth(depthInfo) >= PARAM_RR_DEPTH) ? RussianRouletteProb(bsdfEval) : 1.f;\n"
"	\n"
"	// MIS between direct light sampling and BSDF sampling\n"
"	//\n"
"	// Note: I have to avoiding MIS on the last path vertex\n"
"	__global const LightSource* restrict light = &lights[info->lightIndex];\n"
"\n"
"	const bool misEnabled = !lastPathVertex &&\n"
"			Light_IsEnvOrIntersectable(light) &&\n"
"			CheckDirectHitVisibilityFlags(light, depthInfo, event);\n"
"\n"
"	const float weight = misEnabled ? PowerHeuristic(directLightSamplingPdfW, bsdfPdfW) : 1.f;\n"
"\n"
"	const float3 lightRadiance = VLOAD3F(info->lightRadiance.c);\n"
"	VSTORE3F(bsdfEval * (weight * factor) * lightRadiance, info->lightRadiance.c);\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"	VSTORE3F(factor * lightRadiance, info->lightIrradiance.c);\n"
"#endif\n"
"\n"
"	// Setup the shadow ray\n"
"	const float3 hitPoint = VLOAD3F(&bsdf->hitPoint.p.x);\n"
"	const float distance = info->distance;\n"
"	Ray_Init4(shadowRay, hitPoint, lightRayDir, 0.f, distance, time);\n"
"\n"
"	// Restore the original depthInfo\n"
"	*depthInfo = depthInfoCopy;\n"
"\n"
"	return true;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Kernel parameters\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"#define KERNEL_ARGS_VOLUMES \\\n"
"		, __global PathVolumeInfo *pathVolInfos \\\n"
"		, __global PathVolumeInfo *directLightVolInfos\n"
"#else\n"
"#define KERNEL_ARGS_VOLUMES\n"
"#endif\n"
"\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_0 \\\n"
"		, __global float *filmRadianceGroup0\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_0\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_1 \\\n"
"		, __global float *filmRadianceGroup1\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_1\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_2 \\\n"
"		, __global float *filmRadianceGroup2\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_2\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_3 \\\n"
"		, __global float *filmRadianceGroup3\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_3\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_4 \\\n"
"		, __global float *filmRadianceGroup4\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_4\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_5 \\\n"
"		, __global float *filmRadianceGroup5\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_5\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_6 \\\n"
"		, __global float *filmRadianceGroup6\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_6\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_7 \\\n"
"		, __global float *filmRadianceGroup7\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_7\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_ALPHA \\\n"
"		, __global float *filmAlpha\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_ALPHA\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DEPTH)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DEPTH \\\n"
"		, __global float *filmDepth\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DEPTH\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_POSITION)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_POSITION \\\n"
"		, __global float *filmPosition\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_POSITION\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_GEOMETRY_NORMAL \\\n"
"		, __global float *filmGeometryNormal\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_GEOMETRY_NORMAL\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_SHADING_NORMAL \\\n"
"		, __global float *filmShadingNormal\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_SHADING_NORMAL\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_MATERIAL_ID \\\n"
"		, __global uint *filmMaterialID\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_MATERIAL_ID\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_DIFFUSE \\\n"
"		, __global float *filmDirectDiffuse\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_DIFFUSE\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_GLOSSY \\\n"
"		, __global float *filmDirectGlossy\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_GLOSSY\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_EMISSION)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_EMISSION \\\n"
"		, __global float *filmEmission\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_EMISSION\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_DIFFUSE \\\n"
"		, __global float *filmIndirectDiffuse\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_DIFFUSE\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_GLOSSY \\\n"
"		, __global float *filmIndirectGlossy\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_GLOSSY\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SPECULAR \\\n"
"		, __global float *filmIndirectSpecular\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SPECULAR\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID_MASK)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_MATERIAL_ID_MASK \\\n"
"		, __global float *filmMaterialIDMask\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_MATERIAL_ID_MASK\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_SHADOW_MASK \\\n"
"		, __global float *filmDirectShadowMask\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_SHADOW_MASK\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SHADOW_MASK \\\n"
"		, __global float *filmIndirectShadowMask\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SHADOW_MASK\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_UV)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_UV \\\n"
"		, __global float *filmUV\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_UV\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_RAYCOUNT)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_RAYCOUNT \\\n"
"		, __global float *filmRayCount\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_RAYCOUNT\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_BY_MATERIAL_ID)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_BY_MATERIAL_ID \\\n"
"		, __global float *filmByMaterialID\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_BY_MATERIAL_ID\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_IRRADIANCE \\\n"
"		, __global float *filmIrradiance\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_IRRADIANCE\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_OBJECT_ID)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_OBJECT_ID \\\n"
"		, __global uint *filmObjectID\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_OBJECT_ID\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_OBJECT_ID_MASK)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_OBJECT_ID_MASK \\\n"
"		, __global float *filmObjectIDMask\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_OBJECT_ID_MASK\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_BY_OBJECT_ID)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_BY_OBJECT_ID \\\n"
"		, __global float *filmByObjectID\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_BY_OBJECT_ID\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_SAMPLECOUNT)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_SAMPLECOUNT \\\n"
"		, __global uint *filmSampleCount\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_SAMPLECOUNT\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_CONVERGENCE)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_CONVERGENCE \\\n"
"		, __global float *filmConvergence\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_CONVERGENCE\n"
"#endif\n"
"\n"
"#define KERNEL_ARGS_FILM \\\n"
"		, const uint filmWidth, const uint filmHeight \\\n"
"		, const uint filmSubRegion0, const uint filmSubRegion1 \\\n"
"		, const uint filmSubRegion2, const uint filmSubRegion3 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_0 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_1 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_2 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_3 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_4 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_5 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_6 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_7 \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_ALPHA \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_DEPTH \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_POSITION \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_GEOMETRY_NORMAL \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_SHADING_NORMAL \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_MATERIAL_ID \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_DIRECT_DIFFUSE \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_DIRECT_GLOSSY \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_EMISSION \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_INDIRECT_DIFFUSE \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_INDIRECT_GLOSSY \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SPECULAR \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_MATERIAL_ID_MASK \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_DIRECT_SHADOW_MASK \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SHADOW_MASK \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_UV \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_RAYCOUNT \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_BY_MATERIAL_ID \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_IRRADIANCE \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_OBJECT_ID \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_OBJECT_ID_MASK \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_BY_OBJECT_ID \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_SAMPLECOUNT \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_CONVERGENCE\n"
"\n"
"#define KERNEL_ARGS_INFINITELIGHTS \\\n"
"		, const float worldCenterX \\\n"
"		, const float worldCenterY \\\n"
"		, const float worldCenterZ \\\n"
"		, const float worldRadius\n"
"\n"
"#define KERNEL_ARGS_NORMALS_BUFFER \\\n"
"		, __global const Vector* restrict vertNormals\n"
"#define KERNEL_ARGS_UVS_BUFFER \\\n"
"		, __global const UV* restrict vertUVs\n"
"#define KERNEL_ARGS_COLS_BUFFER \\\n"
"		, __global const Spectrum* restrict vertCols\n"
"#define KERNEL_ARGS_ALPHAS_BUFFER \\\n"
"		, __global const float* restrict vertAlphas\n"
"\n"
"#define KERNEL_ARGS_ENVLIGHTS \\\n"
"		, __global const uint* restrict envLightIndices \\\n"
"		, const uint envLightCount\n"
"\n"
"#define KERNEL_ARGS_INFINITELIGHT \\\n"
"		, __global const float* restrict envLightDistribution\n"
"\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_0)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_0 \\\n"
"		, __global const ImageMap* restrict imageMapDescs, __global const float* restrict imageMapBuff0\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_0\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_1)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_1 \\\n"
"		, __global const float* restrict imageMapBuff1\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_1\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_2)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_2 \\\n"
"		, __global const float* restrict imageMapBuff2\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_2\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_3)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_3 \\\n"
"		, __global const float* restrict imageMapBuff3\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_3\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_4)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_4 \\\n"
"		, __global const float* restrict imageMapBuff4\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_4\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_5)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_5 \\\n"
"		, __global const float* restrict imageMapBuff5\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_5\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_6)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_6 \\\n"
"		, __global const float* restrict imageMapBuff6\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_6\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_7)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_7 \\\n"
"		, __global const float* restrict imageMapBuff7\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_7\n"
"#endif\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGES \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_0 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_1 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_2 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_3 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_4 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_5 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_6 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_7\n"
"\n"
"#define KERNEL_ARGS_FAST_PIXEL_FILTER \\\n"
"		, __global float *pixelFilterDistribution\n"
"\n"
"#define KERNEL_ARGS \\\n"
"		__global GPUTask *tasks \\\n"
"		, __global GPUTaskDirectLight *tasksDirectLight \\\n"
"		, __global GPUTaskState *tasksState \\\n"
"		, __global GPUTaskStats *taskStats \\\n"
"		KERNEL_ARGS_FAST_PIXEL_FILTER \\\n"
"		, __global SamplerSharedData *samplerSharedData \\\n"
"		, __global Sample *samples \\\n"
"		, __global float *samplesData \\\n"
"		KERNEL_ARGS_VOLUMES \\\n"
"		, __global Ray *rays \\\n"
"		, __global RayHit *rayHits \\\n"
"		/* Film parameters */ \\\n"
"		KERNEL_ARGS_FILM \\\n"
"		/* Scene parameters */ \\\n"
"		KERNEL_ARGS_INFINITELIGHTS \\\n"
"		, __global const Material* restrict mats \\\n"
"		, __global const Texture* restrict texs \\\n"
"		, __global const SceneObject* restrict sceneObjs \\\n"
"		, __global const Mesh* restrict meshDescs \\\n"
"		, __global const Point* restrict vertices \\\n"
"		KERNEL_ARGS_NORMALS_BUFFER \\\n"
"		KERNEL_ARGS_UVS_BUFFER \\\n"
"		KERNEL_ARGS_COLS_BUFFER \\\n"
"		KERNEL_ARGS_ALPHAS_BUFFER \\\n"
"		, __global const Triangle* restrict triangles \\\n"
"		, __global const Camera* restrict camera \\\n"
"		/* Lights */ \\\n"
"		, __global const LightSource* restrict lights \\\n"
"		KERNEL_ARGS_ENVLIGHTS \\\n"
"		, __global const uint* restrict meshTriLightDefsOffset \\\n"
"		KERNEL_ARGS_INFINITELIGHT \\\n"
"		, __global const float* restrict lightsDistribution \\\n"
"		, __global const float* restrict infiniteLightSourcesDistribution \\\n"
"		/* Images */ \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGES\n"
"\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// To initialize image maps page pointer table\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_0)\n"
"#define INIT_IMAGEMAPS_PAGE_0 imageMapBuff[0] = imageMapBuff0;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_0\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_1)\n"
"#define INIT_IMAGEMAPS_PAGE_1 imageMapBuff[1] = imageMapBuff1;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_1\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_2)\n"
"#define INIT_IMAGEMAPS_PAGE_2 imageMapBuff[2] = imageMapBuff2;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_2\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_3)\n"
"#define INIT_IMAGEMAPS_PAGE_3 imageMapBuff[3] = imageMapBuff3;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_3\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_4)\n"
"#define INIT_IMAGEMAPS_PAGE_4 imageMapBuff[4] = imageMapBuff4;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_4\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_5)\n"
"#define INIT_IMAGEMAPS_PAGE_5 imageMapBuff[5] = imageMapBuff5;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_5\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_6)\n"
"#define INIT_IMAGEMAPS_PAGE_6 imageMapBuff[6] = imageMapBuff6;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_6\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_7)\n"
"#define INIT_IMAGEMAPS_PAGE_7 imageMapBuff[7] = imageMapBuff7;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_7\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_IMAGEMAPS)\n"
"#define INIT_IMAGEMAPS_PAGES \\\n"
"	__global const float* restrict imageMapBuff[PARAM_IMAGEMAPS_COUNT]; \\\n"
"	INIT_IMAGEMAPS_PAGE_0 \\\n"
"	INIT_IMAGEMAPS_PAGE_1 \\\n"
"	INIT_IMAGEMAPS_PAGE_2 \\\n"
"	INIT_IMAGEMAPS_PAGE_3 \\\n"
"	INIT_IMAGEMAPS_PAGE_4 \\\n"
"	INIT_IMAGEMAPS_PAGE_5 \\\n"
"	INIT_IMAGEMAPS_PAGE_6 \\\n"
"	INIT_IMAGEMAPS_PAGE_7\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGES\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Init Kernels\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void InitSeed(__global GPUTask *tasks,\n"
"		const uint seedBase) {\n"
"	const size_t gid = get_global_id(0);\n"
"\n"
"	// Initialize random number generator\n"
"\n"
"	Seed seed;\n"
"	Rnd_Init(seedBase + gid, &seed);\n"
"\n"
"	// Save the seed\n"
"	__global GPUTask *task = &tasks[gid];\n"
"	task->seed = seed;\n"
"}\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void Init(\n"
"		__global GPUTask *tasks,\n"
"		__global GPUTaskDirectLight *tasksDirectLight,\n"
"		__global GPUTaskState *tasksState,\n"
"		__global GPUTaskStats *taskStats,\n"
"		__global SamplerSharedData *samplerSharedData,\n"
"		__global Sample *samples,\n"
"		__global float *samplesData,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *pathVolInfos,\n"
"#endif\n"
"		__global float *pixelFilterDistribution,\n"
"		__global Ray *rays,\n"
"		__global Camera *camera\n"
"		KERNEL_ARGS_FILM\n"
"#if defined(RENDER_ENGINE_TILEPATHOCL) || defined(RENDER_ENGINE_RTPATHOCL)\n"
"		// cameraFilmWidth/cameraFilmHeight and filmWidth/filmHeight are usually\n"
"		// the same. They are different when doing tile rendering\n"
"		, const uint cameraFilmWidth, const uint cameraFilmHeight\n"
"		, const uint tileStartX, const uint tileStartY\n"
"		, const uint tileWidth, const uint tileHeight\n"
"		, const uint tilePass, const uint aaSamples\n"
"#endif\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"\n"
"	__global GPUTaskState *taskState = &tasksState[gid];\n"
"\n"
"#if defined(RENDER_ENGINE_TILEPATHOCL) || defined(RENDER_ENGINE_RTPATHOCL)\n"
"	if (gid >= filmWidth * filmHeight * aaSamples * aaSamples) {\n"
"		taskState->state = MK_DONE;\n"
"		// Mark the ray like like one to NOT trace\n"
"		rays[gid].flags = RAY_FLAGS_MASKED;\n"
"\n"
"		return;\n"
"	}\n"
"#endif\n"
"\n"
"	// Initialize the task\n"
"	__global GPUTask *task = &tasks[gid];\n"
"	__global GPUTaskDirectLight *taskDirectLight = &tasksDirectLight[gid];\n"
"\n"
"	// Read the seed\n"
"	Seed seedValue = task->seed;\n"
"	// This trick is required by Sampler_GetSample() macro\n"
"	Seed *seed = &seedValue;\n"
"\n"
"	// Initialize the sample and path\n"
"	__global Sample *sample = &samples[gid];\n"
"	__global float *sampleData = Sampler_GetSampleData(sample, samplesData);\n"
"	const bool validSample = Sampler_Init(seed, samplerSharedData, sample, sampleData,\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_CONVERGENCE)\n"
"			filmConvergence,\n"
"#endif\n"
"			filmWidth, filmHeight,\n"
"			filmSubRegion0, filmSubRegion1, filmSubRegion2, filmSubRegion3\n"
"#if defined(RENDER_ENGINE_TILEPATHOCL) || defined(RENDER_ENGINE_RTPATHOCL)\n"
"			, cameraFilmWidth, cameraFilmHeight\n"
"			, tileStartX, tileStartY\n"
"			, tileWidth, tileHeight\n"
"			, tilePass, aaSamples\n"
"#endif\n"
"			);\n"
"\n"
"	if (validSample) {\n"
"		__global float *sampleDataPathBase = Sampler_GetSampleDataPathBase(sample, sampleData);\n"
"\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		PathVolumeInfo_Init(&pathVolInfos[gid]);\n"
"#endif\n"
"\n"
"		// Generate the eye path\n"
"		GenerateEyePath(taskDirectLight, taskState, sample, sampleDataPathBase, camera,\n"
"				filmWidth, filmHeight,\n"
"				filmSubRegion0, filmSubRegion1, filmSubRegion2, filmSubRegion3,\n"
"				pixelFilterDistribution,\n"
"				&rays[gid],\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"				&pathVolInfos[gid],\n"
"#endif\n"
"				seed\n"
"#if defined(RENDER_ENGINE_TILEPATHOCL) || defined(RENDER_ENGINE_RTPATHOCL)\n"
"				, cameraFilmWidth, cameraFilmHeight,\n"
"				tileStartX, tileStartY\n"
"#endif\n"
"				);\n"
"	} else {\n"
"#if defined(RENDER_ENGINE_TILEPATHOCL) || defined(RENDER_ENGINE_RTPATHOCL)\n"
"		taskState->state = MK_DONE;\n"
"#else\n"
"		taskState->state = MK_GENERATE_CAMERA_RAY;\n"
"#endif\n"
"		// Mark the ray like like one to NOT trace\n"
"		rays[gid].flags = RAY_FLAGS_MASKED;\n"
"	}\n"
"\n"
"	// Save the seed\n"
"	task->seed = seedValue;\n"
"\n"
"	__global GPUTaskStats *taskStat = &taskStats[gid];\n"
"	taskStat->sampleCount = 0;\n"
"}\n"
; } }

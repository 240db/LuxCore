#include <string>
namespace slg { namespace ocl {
std::string KernelSource_sampler_metropolis_funcs = 
"#line 2 \"sampler_metropolis_funcs.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2018 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxCoreRender.                                   *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Metropolis Sampler Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 1)\n"
"\n"
"__global float *Sampler_GetSampleData(__global Sample *sample, __global float *samplesData) {\n"
"	const size_t gid = get_global_id(0);\n"
"	return &samplesData[gid * (2 * TOTAL_U_SIZE)];\n"
"}\n"
"\n"
"__global float *Sampler_GetSampleDataPathBase(__global Sample *sample, __global float *sampleData) {\n"
"	return &sampleData[sample->proposed * TOTAL_U_SIZE];\n"
"}\n"
"\n"
"__global float *Sampler_GetSampleDataPathVertex(__global Sample *sample,\n"
"		__global float *sampleDataPathBase, const uint depth) {\n"
"	// The depth used here is counted from the first hit point of the path\n"
"	// vertex (so it is effectively depth - 1)\n"
"	return &sampleDataPathBase[IDX_BSDF_OFFSET + depth * VERTEX_SAMPLE_SIZE];\n"
"}\n"
"\n"
"float Sampler_GetSamplePath(Seed *seed, __global Sample *sample,\n"
"		__global float *sampleDataPathBase, const uint index) {\n"
"	return sampleDataPathBase[index];\n"
"}\n"
"\n"
"float Sampler_GetSamplePathVertex(Seed *seed, __global Sample *sample,\n"
"		__global float *sampleDataPathVertexBase,\n"
"		const uint depth, const uint index) {\n"
"	return sampleDataPathVertexBase[index];\n"
"}\n"
"\n"
"void LargeStep(Seed *seed, __global float *proposedU) {\n"
"	for (int i = 0; i < TOTAL_U_SIZE; ++i)\n"
"		proposedU[i] = Rnd_FloatValue(seed);\n"
"}\n"
"\n"
"float Mutate(const float x, const float randomValue) {\n"
"	const float s1 = 1.f / 512.f;\n"
"	const float s2 = 1.f / 16.f;\n"
"\n"
"	const float dx = s1 / (s1 / s2 + fabs(2.f * randomValue - 1.f)) -\n"
"		s1 / (s1 / s2 + 1.f);\n"
"\n"
"	float mutatedX = x;\n"
"	if (randomValue < .5f) {\n"
"		mutatedX += dx;\n"
"		mutatedX = (mutatedX < 1.f) ? mutatedX : (mutatedX - 1.f);\n"
"	} else {\n"
"		mutatedX -= dx;\n"
"		mutatedX = (mutatedX < 0.f) ? (mutatedX + 1.f) : mutatedX;\n"
"	}\n"
"\n"
"	return mutatedX;\n"
"}\n"
"\n"
"float MutateScaled(const float x, const float range, const float randomValue) {\n"
"	const float s1 = 32.f;\n"
"\n"
"	const float dx = range / (s1 / (1.f + s1) + (s1 * s1) / (1.f + s1) *\n"
"		fabs(2.f * randomValue - 1.f)) - range / s1;\n"
"\n"
"	float mutatedX = x;\n"
"	if (randomValue < .5f) {\n"
"		mutatedX += dx;\n"
"		mutatedX = (mutatedX < 1.f) ? mutatedX : (mutatedX - 1.f);\n"
"	} else {\n"
"		mutatedX -= dx;\n"
"		mutatedX = (mutatedX < 0.f) ? (mutatedX + 1.f) : mutatedX;\n"
"	}\n"
"\n"
"	return mutatedX;\n"
"}\n"
"\n"
"void SmallStep(Seed *seed, __global float *currentU, __global float *proposedU) {\n"
"	// Metropolis return IDX_SCREEN_X and IDX_SCREEN_Y between [0.0, 1.0] instead\n"
"	// that in film pixels like RANDOM and SOBOL samplers\n"
"	proposedU[IDX_SCREEN_X] = MutateScaled(currentU[IDX_SCREEN_X],\n"
"			PARAM_SAMPLER_METROPOLIS_IMAGE_MUTATION_RANGE, Rnd_FloatValue(seed));\n"
"	proposedU[IDX_SCREEN_Y] = MutateScaled(currentU[IDX_SCREEN_Y],\n"
"			PARAM_SAMPLER_METROPOLIS_IMAGE_MUTATION_RANGE, Rnd_FloatValue(seed));\n"
"\n"
"	for (int i = IDX_SCREEN_Y + 1; i < TOTAL_U_SIZE; ++i)\n"
"		proposedU[i] = Mutate(currentU[i], Rnd_FloatValue(seed));\n"
"}\n"
"\n"
"void Sampler_SplatSample(\n"
"		Seed *seed,\n"
"		__global SamplerSharedData *samplerSharedData,\n"
"		__global Sample *sample, __global float *sampleData\n"
"		FILM_PARAM_DECL\n"
"		) {\n"
"	//--------------------------------------------------------------------------\n"
"	// Accept/Reject the sample\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"	uint current = sample->current;\n"
"	uint proposed = sample->proposed;\n"
"\n"
"	if (current == NULL_INDEX) {\n"
"		// It is the very first sample, I have still to initialize the current\n"
"		// sample\n"
"\n"
"		Film_AddSample(sample->result.pixelX, sample->result.pixelY,\n"
"				&sample->result, 1.f\n"
"				FILM_PARAM);\n"
"\n"
"		sample->currentResult = sample->result;\n"
"		sample->totalI = SampleResult_Radiance_Y(&sample->result);\n"
"\n"
"		current = proposed;\n"
"		proposed ^= 1;\n"
"	} else {\n"
"		const float currentI = SampleResult_Radiance_Y(&sample->currentResult);\n"
"\n"
"		float proposedI = SampleResult_Radiance_Y(&sample->result);\n"
"		proposedI = (isnan(proposedI) || isinf(proposedI)) ? 0.f : proposedI;\n"
"\n"
"		float totalI = sample->totalI;\n"
"		uint largeMutationCount = sample->largeMutationCount;\n"
"		uint smallMutationCount = sample->smallMutationCount;\n"
"		if (smallMutationCount == 0) {\n"
"			// It is a large mutation\n"
"			totalI += proposedI;\n"
"			largeMutationCount += 1;\n"
"\n"
"			sample->totalI = totalI;\n"
"			sample->largeMutationCount = largeMutationCount;\n"
"		}\n"
"\n"
"		const float invMeanI = (totalI > 0.f) ? (largeMutationCount / totalI) : 1.f;\n"
"\n"
"		// Calculate accept probability from old and new image sample\n"
"		uint consecutiveRejects = sample->consecutiveRejects;\n"
"\n"
"		float accProb;\n"
"		if ((currentI > 0.f) && (consecutiveRejects < PARAM_SAMPLER_METROPOLIS_MAX_CONSECUTIVE_REJECT))\n"
"			accProb = min(1.f, proposedI / currentI);\n"
"		else\n"
"			accProb = 1.f;\n"
"\n"
"		const float newWeight = accProb + ((smallMutationCount == 0) ? 1.f : 0.f);\n"
"		float weight = sample->weight;\n"
"		weight += 1.f - accProb;\n"
"\n"
"		const float rndVal = Rnd_FloatValue(seed);\n"
"\n"
"		/*if (get_global_id(0) == 0)\n"
"			printf(\"[%d, %d][%f, %f][%d] Current: (%f, %f, %f) [%f/%f] Proposed: (%f, %f, %f) [%f] accProb: %f <%f>\\n\",\n"
"					current, proposed,\n"
"					currentI, proposedI,\n"
"					consecutiveRejects,\n"
"					sample->currentResult.radiancePerPixelNormalized[0].c[0], sample->currentResult.radiancePerPixelNormalized[0].c[1], sample->currentResult.radiancePerPixelNormalized[0].c[2], weight, sample->weight,\n"
"					sample->result.radiancePerPixelNormalized[0].c[0], sample->result.radiancePerPixelNormalized[0].c[1], sample->result.radiancePerPixelNormalized[0].c[2], newWeight,\n"
"					accProb, rndVal);*/\n"
"\n"
"		__global SampleResult *contrib;\n"
"		float norm;\n"
"		if ((accProb == 1.f) || (rndVal < accProb)) {\n"
"			/*if (get_global_id(0) == 0)\n"
"				printf(\"\\t\\tACCEPTED ! [%f]\\n\", currentI);*/\n"
"\n"
"			// Add accumulated contribution of previous reference sample\n"
"			norm = weight / (currentI * invMeanI + PARAM_SAMPLER_METROPOLIS_LARGE_STEP_RATE);\n"
"			contrib = &sample->currentResult;\n"
"\n"
"			// Save new contributions for reference\n"
"			weight = newWeight;\n"
"			current ^= 1;\n"
"			proposed ^= 1;\n"
"\n"
"			consecutiveRejects = 0;\n"
"		} else {\n"
"			/*if (get_global_id(0) == 0)\n"
"				printf(\"\\t\\tREJECTED ! [%f]\\n\", proposedI);*/\n"
"\n"
"			// Add contribution of new sample before rejecting it\n"
"			norm = newWeight / (proposedI * invMeanI + PARAM_SAMPLER_METROPOLIS_LARGE_STEP_RATE);\n"
"			contrib = &sample->result;\n"
"\n"
"			++consecutiveRejects;\n"
"		}\n"
"\n"
"		if (norm > 0.f) {\n"
"			/*if (get_global_id(0) == 0)\n"
"				printf(\"\\t\\tContrib: (%f, %f, %f) [%f] consecutiveRejects: %d\\n\",\n"
"						contrib->radiancePerPixelNormalized[0].c[0],\n"
"						contrib->radiancePerPixelNormalized[0].c[1],\n"
"						contrib->radiancePerPixelNormalized[0].c[2],\n"
"						norm, consecutiveRejects);*/\n"
"\n"
"			Film_AddSample(contrib->pixelX, contrib->pixelY,\n"
"					contrib, norm\n"
"					FILM_PARAM);\n"
"		}\n"
"\n"
"		// Check if it is an accepted mutation\n"
"		if (consecutiveRejects == 0) {\n"
"			// I can now (after Film_SplatSample()) overwrite sample->currentResult and sample->result\n"
"			sample->currentResult = sample->result;\n"
"		}\n"
"\n"
"		sample->weight = weight;\n"
"		sample->consecutiveRejects = consecutiveRejects;\n"
"	}\n"
"\n"
"	sample->current = current;\n"
"	sample->proposed = proposed;\n"
"}\n"
"\n"
"void Sampler_NextSample(\n"
"		Seed *seed,\n"
"		__global SamplerSharedData *samplerSharedData,\n"
"		__global Sample *sample, __global float *sampleData,\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_CONVERGENCE)\n"
"		__global float *filmConvergence,\n"
"#endif\n"
"		const uint filmWidth, const uint filmHeight,\n"
"		const uint filmSubRegion0, const uint filmSubRegion1,\n"
"		const uint filmSubRegion2, const uint filmSubRegion3) {\n"
"	//--------------------------------------------------------------------------\n"
"	// Mutate the sample\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"	__global float *proposedU = &sampleData[sample->proposed * TOTAL_U_SIZE];\n"
"	if (Rnd_FloatValue(seed) < PARAM_SAMPLER_METROPOLIS_LARGE_STEP_RATE) {\n"
"		LargeStep(seed, proposedU);\n"
"		sample->smallMutationCount = 0;\n"
"	} else {\n"
"		__global float *currentU = &sampleData[sample->current * TOTAL_U_SIZE];\n"
"\n"
"		SmallStep(seed, currentU, proposedU);\n"
"		sample->smallMutationCount += 1;\n"
"	}\n"
"}\n"
"\n"
"bool Sampler_Init(Seed *seed, __global SamplerSharedData *samplerSharedData,\n"
"		__global Sample *sample, __global float *sampleData,\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_CONVERGENCE)\n"
"		__global float *filmConvergence,\n"
"#endif\n"
"		const uint filmWidth, const uint filmHeight,\n"
"		const uint filmSubRegion0, const uint filmSubRegion1,\n"
"		const uint filmSubRegion2, const uint filmSubRegion3) {\n"
"	sample->totalI = 0.f;\n"
"	sample->largeMutationCount = 1.f;\n"
"\n"
"	sample->current = NULL_INDEX;\n"
"	sample->proposed = 1;\n"
"\n"
"	sample->smallMutationCount = 0;\n"
"	sample->consecutiveRejects = 0;\n"
"\n"
"	sample->weight = 0.f;\n"
"\n"
"	__global float *sampleDataPathBase = Sampler_GetSampleDataPathBase(sample, sampleData);\n"
"	LargeStep(seed, sampleDataPathBase);\n"
"\n"
"	return true;\n"
"}\n"
"\n"
"#endif\n"
; } }

#include <string>
namespace slg { namespace ocl {
std::string KernelSource_materialdefs_funcs_glass = 
"#line 2 \"materialdefs_funcs_glass.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2018 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxCoreRender.                                   *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Glass material\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined (PARAM_ENABLE_MAT_GLASS)\n"
"\n"
"BSDFEvent GlassMaterial_GetEventTypes() {\n"
"	return SPECULAR | REFLECT | TRANSMIT;\n"
"}\n"
"\n"
"bool GlassMaterial_IsDelta() {\n"
"	return true;\n"
"}\n"
"\n"
"float3 GlassMaterial_Evaluate(\n"
"		__global HitPoint *hitPoint, const float3 lightDir, const float3 eyeDir,\n"
"		BSDFEvent *event, float *directPdfW,\n"
"		const float3 ktTexVal, const float3 krTexVal,\n"
"		const float3 nc, const float3 nt, const float cauchyC) {\n"
"	return BLACK;\n"
"}\n"
"\n"
"float3 GlassMaterial_WaveLength2RGB(const float waveLength) {\n"
"	float r, g, b;\n"
"	if ((waveLength >= 380.f) && (waveLength < 440.f)) {\n"
"		r = -(waveLength - 440.f) / (440 - 380.f);\n"
"		g = 0.f;\n"
"		b = 1.f;\n"
"	} else if ((waveLength >= 440.f) && (waveLength < 490.f)) {\n"
"		r = 0.f;\n"
"		g = (waveLength - 440.f) / (490.f - 440.f);\n"
"		b = 1.f;\n"
"	} else if ((waveLength >= 490.f) && (waveLength < 510.f)) {\n"
"		r = 0.f;\n"
"		g = 1.f;\n"
"		b = -(waveLength - 510.f) / (510.f - 490.f);\n"
"	} else if ((waveLength >= 510.f) && (waveLength < 580.f)) {\n"
"		r = (waveLength - 510.f) / (580.f - 510.f);\n"
"		g = 1.f;\n"
"		b = 0.f;\n"
"	} else if ((waveLength >= 580.f) && (waveLength < 645.f)) {\n"
"		r = 1.f;\n"
"		g = -(waveLength - 645.f) / (645 - 580.f);\n"
"		b = 0.f;\n"
"	} else if ((waveLength >= 645.f) && (waveLength < 780.f)) {\n"
"		r = 1.f;\n"
"		g = 0.f;\n"
"		b = 0.f;\n"
"	} else\n"
"		return BLACK;\n"
"\n"
"	// The intensity fall off near the upper and lower limits\n"
"	float factor;\n"
"	if ((waveLength >= 380.f) && (waveLength < 420.f))\n"
"		factor = .3f + .7f * (waveLength - 380.f) / (420.f - 380.f);\n"
"	else if ((waveLength >= 420) && (waveLength < 700))\n"
"		factor = 1.f;\n"
"	else\n"
"		factor = .3f + .7f * (780.f - waveLength) / (780.f - 700.f);\n"
"\n"
"	const float3 result = (float3)(r, g, b) * factor;\n"
"\n"
"	/*\n"
"	Spectrum white;\n"
"	for (u_int i = 380; i < 780; ++i)\n"
"		white += WaveLength2RGB(i);\n"
"	white *= 1.f / 400.f;\n"
"	cout << std::setprecision(std::numeric_limits<float>::digits10 + 1) << white.c[0] << \", \" << white.c[1] << \", \" << white.c[2] << \"\\n\";\n"
"	 \n"
"	 Result: 0.5652729, 0.36875, 0.265375\n"
"	 */\n"
"\n"
"	// To normalize the output\n"
"	const float3 normFactor = (float3)(1.f / .5652729f, 1.f / .36875f, 1.f / .265375f);\n"
"	\n"
"	return result * normFactor;\n"
"}\n"
"\n"
"#define Sqr(a) (a * a)\n"
"float GlassMaterial_WaveLength2IOR(const float waveLength, const float IOR, const float C) {\n"
"	// Cauchy's equation for relationship between the refractive index and wavelength\n"
"	// note: Cauchy's lambda is expressed in micrometers while waveLength is in nanometers\n"
"\n"
"	// This is the formula suggested by Neo here:\n"
"	// https://github.com/LuxCoreRender/BlendLuxCore/commit/d3fed046ab62e18226e410b42a16ca1bccefb530#commitcomment-26617643\n"
"	//const float B = IOR - C / Sqr(589.f / 1000.f);\n"
"\n"
"	// The B used by old LuxRender\n"
"	const float B = IOR;\n"
"\n"
"	// Cauchy's equation\n"
"	const float cauchyEq = B + C / Sqr(waveLength / 1000.f);\n"
"\n"
"	return cauchyEq;\n"
"}\n"
"#undef Sqr\n"
"\n"
"float3 GlassMaterial_EvalSpecularReflection(__global HitPoint *hitPoint,\n"
"		const float3 localFixedDir, const float3 kr,\n"
"		const float nc, const float nt,\n"
"		float3 *localSampledDir) {\n"
"	if (Spectrum_IsBlack(kr))\n"
"		return BLACK;\n"
"\n"
"	const float costheta = CosTheta(localFixedDir);\n"
"	*localSampledDir = (float3)(-localFixedDir.x, -localFixedDir.y, localFixedDir.z);\n"
"\n"
"	const float ntc = nt / nc;\n"
"	return kr * FresnelCauchy_Evaluate(ntc, costheta);\n"
"}\n"
"\n"
"float3 GlassMaterial_EvalSpecularTransmission(__global HitPoint *hitPoint,\n"
"		const float3 localFixedDir, const float u0,\n"
"		const float3 kt, const float nc, const float nt, const float cauchyC,\n"
"		float3 *localSampledDir) {\n"
"	if (Spectrum_IsBlack(kt))\n"
"		return BLACK;\n"
"\n"
"	// Compute transmitted ray direction\n"
"	float3 lkt;\n"
"	float lnt;\n"
"	if (cauchyC > 0.f) {\n"
"		// Select the wavelength to sample\n"
"		const float waveLength = mix(380.f, 780.f, u0);\n"
"\n"
"		lnt = GlassMaterial_WaveLength2IOR(waveLength, nt, cauchyC);\n"
"\n"
"		lkt = kt * GlassMaterial_WaveLength2RGB(waveLength);\n"
"	} else {\n"
"		lnt = nt;\n"
"		lkt = kt;\n"
"	}\n"
"\n"
"	const float ntc = lnt / nc;\n"
"	const float costheta = CosTheta(localFixedDir);\n"
"	const bool entering = (costheta > 0.f);\n"
"	const float eta = entering ? (nc / lnt) : ntc;\n"
"	const float eta2 = eta * eta;\n"
"	const float sini2 = SinTheta2(localFixedDir);\n"
"	const float sint2 = eta2 * sini2;\n"
"\n"
"	// Handle total internal reflection for transmission\n"
"	if (sint2 >= 1.f)\n"
"		return BLACK;\n"
"\n"
"	const float cost = sqrt(fmax(0.f, 1.f - sint2)) * (entering ? -1.f : 1.f);\n"
"	*localSampledDir = (float3)(-eta * localFixedDir.x, -eta * localFixedDir.y, cost);\n"
"\n"
"	float ce;\n"
"//	if (!hitPoint.fromLight)\n"
"		ce = (1.f - FresnelCauchy_Evaluate(ntc, cost)) * eta2;\n"
"//	else {\n"
"//		const float absCosSampledDir = fabsf(CosTheta(*localSampledDir));\n"
"//		ce = (1.f - FresnelTexture::CauchyEvaluate(ntc, costheta)) * fabsf(localFixedDir.z / absCosSampledDir);\n"
"//	}\n"
"\n"
"	return lkt * ce;\n"
"}\n"
"\n"
"float3 GlassMaterial_Sample(\n"
"		__global HitPoint *hitPoint, const float3 localFixedDir, float3 *localSampledDir,\n"
"		const float u0, const float u1,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float passThroughEvent,\n"
"#endif\n"
"		float *pdfW, float *absCosSampledDir, BSDFEvent *event,\n"
"		const float3 ktTexVal, const float3 krTexVal,\n"
"		const float nc, const float nt, const float cauchyC) {\n"
"	const float3 kt = Spectrum_Clamp(ktTexVal);\n"
"	const float3 kr = Spectrum_Clamp(krTexVal);\n"
"\n"
"	float3 transLocalSampledDir; \n"
"	const float3 trans = GlassMaterial_EvalSpecularTransmission(hitPoint, localFixedDir, u0,\n"
"			kt, nc, nt, cauchyC, &transLocalSampledDir);\n"
"	\n"
"	float3 reflLocalSampledDir;\n"
"	const float3 refl = GlassMaterial_EvalSpecularReflection(hitPoint, localFixedDir,\n"
"			kr, nc, nt, &reflLocalSampledDir);\n"
"\n"
"	// Decide to transmit or reflect\n"
"	float threshold;\n"
"	if (!Spectrum_IsBlack(refl)) {\n"
"		if (!Spectrum_IsBlack(trans)) {\n"
"			// Importance sampling\n"
"			const float reflFilter = Spectrum_Filter(refl);\n"
"			const float transFilter = Spectrum_Filter(trans);\n"
"			threshold = transFilter / (reflFilter + transFilter);\n"
"		} else\n"
"			threshold = 0.f;\n"
"	} else {\n"
"		if (!Spectrum_IsBlack(trans))\n"
"			threshold = 1.f;\n"
"		else\n"
"			return BLACK;\n"
"	}\n"
"\n"
"	float3 result;\n"
"	if (passThroughEvent < threshold) {\n"
"		// Transmit\n"
"\n"
"		*localSampledDir = transLocalSampledDir;\n"
"\n"
"		*event = SPECULAR | TRANSMIT;\n"
"		*pdfW = threshold;\n"
"	\n"
"		result = trans;\n"
"	} else {\n"
"		// Reflect\n"
"\n"
"		*localSampledDir = reflLocalSampledDir;\n"
"\n"
"		*event = SPECULAR | REFLECT;\n"
"		*pdfW = 1.f - threshold;\n"
"		\n"
"		result = refl;\n"
"	}\n"
"	\n"
"	*absCosSampledDir = fabs(CosTheta(*localSampledDir));\n"
"\n"
"	return result / *pdfW;\n"
"}\n"
"\n"
"#endif\n"
; } }
